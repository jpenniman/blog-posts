---
layout: post
title: OneWay vs Async in WCF
date: 2013-11-16 14:35:00.000000000 -05:00
author: Jason M Penniman
excerpt: "<p>On a recent project, there was some debate about the behavior of OneWay OperationContracts,
  so I thought I'd put together a little example. Specifically, the debate centered
  around when control is returned back to the calling routine. Let's take a look at
  the MSDN docs...<br />http://msdn.microsoft.com/en-us/library/system.servicemodel.operationcontractat...</p>"
category: Blog
---
<p>Download the sample code from here: <a href="/examples/OneWayServiceExample.zip">OneWayExample</a></p>

<p>On a recent project, there was some debate about the behavior of OneWay OperationContracts, so I thought I'd put together a little example.<br />Specifically, the debate centered around when control is returned back to the calling routine. Let's take a look at the MSDN docs...</p>
<p>http://msdn.microsoft.com/en-us/library/system.servicemodel.operationcontractattribute.isoneway(v=vs.110).aspx</p>
<p style="padding-left: 30px;">"<span style="color: #2a2a2a; font-family: 'Segoe UI', 'Lucida Grande', Verdana, Arial, Helvetica, sans-serif; font-size: 13px; line-height: 18px;">Use the </span><span style="color: #2a2a2a; font-family: 'Segoe UI', 'Lucida Grande', Verdana, Arial, Helvetica, sans-serif; font-size: 13px; line-height: 18px;">IsOneWay</span><span style="color: #2a2a2a; font-family: 'Segoe UI', 'Lucida Grande', Verdana, Arial, Helvetica, sans-serif; font-size: 13px; line-height: 18px;"> property to indicate that an operation does not return a reply message. This type of operation is useful for notifications or event-style communication, especially in two-way communication. </span>"<br />"<span style="color: #2a2a2a; font-family: 'Segoe UI', 'Lucida Grande', Verdana, Arial, Helvetica, sans-serif; font-size: 13px; line-height: 18px;">Specifying that an operation is a one-way operation means only that there is no response message. It is possible to block if a connection cannot be made, or the outbound message is very large, or if the service cannot read inbound information fast enough. If a client requires a non-blocking call, generate </span><span style="color: #2a2a2a; font-family: 'Segoe UI', 'Lucida Grande', Verdana, Arial, Helvetica, sans-serif; font-size: 13px; line-height: 18px;"><a href="http://msdn.microsoft.com/en-us/library/system.servicemodel.operationcontractattribute.asyncpattern(v=vs.110).aspx" rel="nofollow" style="color: #03697a; text-decoration: none;">AsyncPattern</a> </span><span style="color: #2a2a2a; font-family: 'Segoe UI', 'Lucida Grande', Verdana, Arial, Helvetica, sans-serif; font-size: 13px; line-height: 18px;">operations.</span>"</p>
<p>I also encourage you to read the MSDN entry on OneWay Services:<br />http://msdn.microsoft.com/en-us/library/ms730149(v=vs.110).aspx</p>
<p style="padding-left: 30px;">"<span style="color: #2a2a2a; font-family: 'Segoe UI', 'Lucida Grande', Verdana, Arial, Helvetica, sans-serif; font-size: 13px; line-height: 18px;">It is important to realize that while some one-way applications return as soon as the outbound data is written to the network connection, in several scenarios the implementation of a binding or of a service can cause a WCF client to block using one-way operations. In WCF client applications, the WCF client object does not return until the outbound data has been written to the network connection. This is true for all message exchange patterns, including one-way operations; this means that any problem writing the data to the transport prevents the client from returning. Depending upon the problem, the result could be an exception or a delay in sending messages to the service.</span>"</p>
<p>A key difference between OneWay and Async is the thread in which the call is made.  With OneWay, the call is made on the same thread as the calling routine, so it IS, as the docs point out, a blocking operation.  However, OneWay only waits for a receipt acknowledgement (ACK) from the service that the request was received--it does not wait for the service to finish processing.  Under ideal conditions, there is no wait, and if the caller doesn't care about whether the service was successful, this approach can actually be more performant than an async call.</p>
<p><br />Async calls happen on a separate background worker thread from the calling routing.  This means that there is no blocking at all (well, almost not at all... we'll take a look at this a bit later)--the call, the wait for the ACK, and wait for response, happens on the background thread.</p>
<p> </p>
<h3>Let's look at a simple experiment.</h3>
<p>Let's take a simple service that simulates some work:<br /><br /></p>
<pre class="csharpcode">[ServiceContract]<br /><span class="kwrd">public</span><span class="kwrd">interface</span> IExampleService<br />    {<br />        [OperationContract]<br /><span class="kwrd">long</span> DoWork();<br />        [OperationContract(IsOneWay = <span class="kwrd">true</span>)]<br /><span class="kwrd">void</span> DoOneWayWork();<br />    }</pre>
<p><br />Then, a simple client that makes calls to the servers and tracks the timing:<br /><br /></p>
<pre class="csharpcode"><span class="kwrd">class</span> Client<br />    {<br /><span class="kwrd">static</span><span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)<br />        {<br /><span class="kwrd">using</span> (Services.ExampleServiceClient proxy = <span class="kwrd">new</span> ExampleServiceClient())<br />            {<br />                Stopwatch sw = <span class="kwrd">new</span> Stopwatch();<br />                sw.Start();<br /><span class="kwrd">try</span><br />                {<br />                    proxy.DoWork();<br />                }<br /><span class="kwrd">catch</span> (Exception ex)<br />                {<br />                    Console.WriteLine(ex.Message + <span class="str">" "</span>);<br />                }<br /><br />                sw.Stop();<br />                Console.WriteLine(<span class="str">"proxy.DoWork(): Elapsed Time: {0}ms\n"</span>, sw.ElapsedMilliseconds);<br />                sw.Reset();<br />                sw.Start();<br /><span class="kwrd">try</span><br />                {<br />                    proxy.DoOneWayWork();<br />                }<br /><span class="kwrd">catch</span> (Exception ex)<br />                {<br />                    Console.WriteLine(ex.Message + <span class="str">" "</span>);<br />                }<br />                sw.Stop();<br />                Console.WriteLine(<span class="str">"proxy.DoOneWayWork(): Elapsed Time: {0}ms\n"</span>, sw.ElapsedMilliseconds);<br />                sw.Reset();<br />                sw.Start();<br /><span class="kwrd">try</span><br />                {<br />                    proxy.DoWorkAsync();<br />                }<br /><span class="kwrd">catch</span> (Exception ex)<br />                {<br />                    Console.WriteLine(ex.Message + <span class="str">" "</span>);<br />                }<br />                sw.Stop();<br />                Console.WriteLine(<span class="str">"proxy.DoWorkAsync(): Elapsed Time: {0}ms\n"</span>, sw.ElapsedMilliseconds);<br />                sw.Reset();<br />            }<br />            Console.ReadLine();<br />        }<br />    }</pre>
<p> </p>
<p> </p>
<h4>Scenario 1: Happy Service, Happy Client</h4>
<p>If all is well, we can see that calls to the service with OneWay and Async are fast.  Note that OneWay is actually faster in this case.  Something to consider if you're looking for "fire-and-forget", but still want to know that the service was reachable.</p>
<div class="separator" style="clear: both; text-align: center;"><img src="https://1.bp.blogspot.com/-jGwniJkgvl0/Uofc2HfktgI/AAAAAAAAAWM/SRbez_sPU1Q/s1600/Screen+Shot+2013-11-16+at+3.14.46+PM.png" border="0" alt="OneWay vs Async in WCF" style="border: 0px;" /></div>
<p>As expected, the synchronous call blocks for as long as the service is doing its work, plus communication overhead.</p>
<p> </p>
<h4>Scenario 2: Down Service</h4>
<p>Now let's take a look at the behavior if the service is down, or the endpoint is otherwise unreachable.</p>
<div class="separator" style="clear: both; text-align: center;"><img src="https://2.bp.blogspot.com/-SMMgsBKLUjo/Uofd0uCNRlI/AAAAAAAAAWY/Ek4hFCxxk8c/s1600/Screen+Shot+2013-11-16+at+4.03.56+PM.png" border="0" alt="OneWay vs Async in WCF" width="640" height="216" style="border: 0px;" /></div>
<p><br />Notice that the OneWay Service, as the docs highlight, waits for the ACK and blocks for 2 seconds while the call is attempted and the exception generated.<br />The Async, however, because the communication attempt is on a different thread, there is no blocking of the calling thread.</p>
<p> </p>
<h4>Scenario 3: Busy Service</h4>
<p>What if the service is reachable, but all available connections are used, and our request has to wait in the queue for processing.<br />For testing, we'll throttle the connections to 1, and spin up two clients.<br /><br /></p>
<pre class="csharpcode"><span class="kwrd">&lt;</span><span class="html">serviceThrottling</span><span class="attr">maxConcurrentCalls</span><span class="kwrd">="1"</span><span class="attr">maxConcurrentInstances</span><span class="kwrd">="1"</span><span class="attr">maxConcurrentSessions</span><span class="kwrd">="1"</span><span class="kwrd">/&gt;</span></pre>
<p> </p>
<div class="separator" style="clear: both; text-align: center;"><img src="https://4.bp.blogspot.com/-xJrUUhspwdc/UofeeW6yjHI/AAAAAAAAAWg/JFMJKNcDcGU/s1600/Screen+Shot+2013-11-16+at+3.28.47+PM.png" border="0" alt="OneWay vs Async in WCF" style="border: 0px;" /></div>
<p><br />If the service is busy, as expected based on our readings on MSDN, the OneWay service call blocks while it waits for that receipt acknowledgement from the service.</p>
<p> </p>
<h3>Conclusion</h3>
<p>As we can see from our readings on MSDN and this little experiment, OneWay does block execution of the calling thread.  How long it blocks depends on the scenario. If everything is hunky-dory, the block is negligible, and could even be faster than an async call.  If there is an issue somewhere along the way, however, it behaves just like our standard two-way synchronous calls.</p>
